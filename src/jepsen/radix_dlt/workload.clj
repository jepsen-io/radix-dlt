(ns jepsen.radix-dlt.workload
  "A generator, client, and checker for RadixDLT"
  (:require [clojure.tools.logging :refer [info warn]]
            [dom-top.core :refer [assert+]]
            [jepsen [checker :as checker]
                    [client :as client]
                    [generator :as gen]
                    [util :as util]]
            [jepsen.radix-dlt [checker :as rchecker]
                              [client :as rc]
                              [util :as u]]
            [slingshot.slingshot :refer [try+ throw+]]))

(defn accounts
  "This structure helps us track the mapping between our logical account IDs
  (small integers), keypairs, and account addresses. It comprises a collection
  of accounts, each a map of {:id, :key-pair, :address}, and indices :by-id,
  :by-address"
  []
  {:accounts       []
   :by-id          {}
   :by-address     {}
   :by-address-str {}})

(defn conj-account
  "Adds an account to an accounts structure."
  [accounts account]
  {:accounts    (conj  (:accounts accounts)   account)
   :by-id       (assoc (:by-id accounts)      (:id account)       account)
   :by-address  (assoc (:by-address accounts) (:address account)  account)
   :by-address-str (assoc (:by-address-str accounts)
                          (str (:address account))
                          account)})

(defn conj-small-account
  "I don't know a good word for this. The default accounts are generated by
  calling (rc/key-pair 1), (rc/key-pair 2), etc, up to 5. We're going to
  generate *more* accounts than just 5: 6, 7, 8, etc. We call these \"small\"
  accounts, as opposed to ones with larger key pairs."
  [accounts id]
  (let [key-pair (rc/key-pair id)]
    (conj-account
      accounts
      {:id        id
       :key-pair  key-pair
       :address   (rc/key-pair->account-address key-pair)})))

(defn id->address
  "Converts an ID to an address, given an accounts structure."
  [accounts id]
  (-> accounts :by-id (get id) :address
      (assert+ {:type :no-such-id
                :id   id})))

(defn address-str->id
  "Converts an address string to an ID, given an accounts structure."
  [accounts address]
  (-> accounts :by-address-str (get address) :id))

(defn id->key-pair
  "Converts an ID to a key-pair, given an accounts structure."
  [accounts id]
  (-> accounts :by-id (get id) :key-pair
      (assert+ {:type :no-such-id
                :id   id})))

(defn rand-id
  "A random account ID drawn from the accounts map."
  [accounts]
  (-> accounts :accounts rand-nth :id
      (assert+ {:type :no-id?
                :accounts accounts})))

(defn initial-accounts
  "Constructs the initial accounts map, where accounts 1-5 are the hardcoded
  accounts from the universe."
  []
  (reduce (fn [accounts id]
            (let [key-pair (rc/key-pair id)]
              (conj-account
                accounts
                {:id        id
                 :key-pair  key-pair
                 :address   (rc/key-pair->account-address key-pair)})))
          (accounts)
          u/default-account-ids))

(defmacro with-errors
  "Takes an operation and a body. Evaluates body, converting known exceptions to fail/info operations."
  [op & body]
  `(try+ ~@body
         (catch [:type :timeout] e#
           (assoc ~op :type :info, :error :timeout))
         (catch [:type :radix-dlt/failure, :code 1500] e#
           (assoc ~op :type :fail, :error [:substate-not-found
                                           (:message e#)]))
         (catch [:type :radix-dlt/failure, :code 2515] e#
           (assoc ~op :type :fail, :error :insufficient-balance))))


(defrecord Client [conn node accounts token-rri]
  client/Client
  (open! [this test node]
    (assoc this
           :node node
           :conn (rc/open node)))

  (setup! [this test]
    ; Fetch the native token RRI
    (locking token-rri
      (when-not (realized? token-rri)
        (deliver token-rri (:rri (rc/native-token conn))))))

  (invoke! [this test {:keys [:f :value] :as op}]
    (with-errors op
      (case f
        :txn
        (let [; Map account IDs to addresses and add the token RRI to each op.
              ops (map (fn [{:keys [type] :as op}]
                         (case type
                           :transfer (let [{:keys [from to amount rri]} op]
                                       [type
                                        (id->address @accounts from)
                                        (id->address @accounts to)
                                        amount
                                        rri])))
                       (:ops value))
              ;_ (info :ops ops)
              ; Execute transaction
              txn' (rc/txn! conn
                            (id->key-pair @accounts (:from value))
                            (str "t" (:id value))
                            ops)
              ; No matter what, we at least know our transaction ID
              value' (assoc value :tx-id (:id txn'))
              ; Await execution
              status (-> txn' :status deref :status)]
          (assoc op :type (case status
                            :confirmed  :ok
                            :pending    :info
                            :failed     :fail)))

        :txn-log
        (let [; A little helper: we want to translate addresses into numeric IDs
              ; when we know them, but leave them as big hex strings otherwise
              address->id (fn [address]
                            (or (address-str->id @accounts address)
                                address))
              log (->> (rc/txn-history conn (id->address @accounts
                                                         (:account value)))
                       reverse
                       (mapv (fn [{:keys [fee message actions]}]
                               {:fee      fee
                                :message  message
                                ; Rewrite accounts to IDs
                                :actions (mapv (fn [action]
                                                 (-> action
                                                     (update :from address->id)
                                                     (update :to address->id)))
                                               actions)})))
              value'  (assoc value :txns log)]
          (assoc op :type :ok :value value'))

        :balance
        (let [b (->> (rc/token-balances conn (id->address @accounts
                                                          (:account value)))
                     :balances
                     (filter (comp #{@token-rri} :rri))
                     first
                     :amount)
              value' (assoc value :balance b)]
          (assoc op :type :ok, :value value')))))

  (teardown! [this test])

  (close! [this test]))

(defn client
  "Constructs a fresh Jepsen client. Takes an accounts atom and an rri promise"
  [accounts token-rri]
  (Client. nil nil accounts token-rri))

;; Generator

(defn gen-key
  "Turns a key index into a key on a generator."
  [gen ki]
  (-> gen :pool (nth ki)))

(defn gen-rand-key
  "Selects a random key from a Generator's pool."
  [gen]
  ; Choosing our random numbers from this range converts them to an
  ; index in the range [0, key-count]
  (case (:key-dist gen)
    :uniform (rand-int (:key-count gen))

    :exponential
    (let [key-dist-base (:key-dist-base gen)
          key-count     (:key-count gen)
          ; Choosing our random numbers from this range converts them to an
          ; index in the range [0, key-count).
          key-dist-scale (-> (Math/pow key-dist-base key-count)
                             (- 1)
                             (* key-dist-base)
                             (/ (- key-dist-base 1)))
          ki (-> (rand key-dist-scale)
                 (+ key-dist-base)
                 Math/log
                 (/ (Math/log key-dist-base))
                 (- 1)
                 Math/floor
                 long)]
      (-> gen :key-pool (nth ki)))))

(defn gen-rand-read-key
  "Selects a random key from a Generator for a read. We sometimes emit reads of
  the default account 1, in addition to those in the pool."
  [gen]
  (if (< (rand) (/ (inc (:key-count gen))))
    1
    (gen-rand-key gen)))

(defn gen-record-write!
  "Takes a generator and a key index, and records that key as having been
  written. If the key is written more than max-writes-per-key, replaces the key
  in the pool. As a side effect, adds new keys to the accounts index."
  [gen k]
  (let [writes (-> gen :write-counts (get k 0) inc)]
    ; If we've written it too much, replace it with a new key.
    (if (<= (:max-writes-per-key gen) writes)
      (let [k' (:next-key gen)
            ki (.indexOf ^java.util.List (:key-pool gen) k)]
        ; Record this new account
        (swap! (:accounts gen) conj-small-account k')

        (assoc gen
               :next-key     (inc k')
               :key-pool     (assoc (:key-pool gen) ki k')
               :write-counts (-> (:write-counts gen)
                                 (dissoc k)
                                 (assoc k' 0))))
      ; Otherwise, just record the write
      (assoc-in gen [:write-counts k] writes))))

(defn gen-first-write-of?
  "Takes a generator and a key, and returns true if this is the first
  write of that key index."
  [gen k]
  (-> gen :write-counts (get k 0) zero?))

(defn gen-transfer!
  "Takes a generator. Generates a series of transfer actions, and returns
  [transfer gen'], where gen' records the writes of keys involved in the
  transfer. As a side effect, updates the account structure with any new keys."
  [gen]
  (let [; What account is performing this transaction?
        from  (gen-rand-key gen)
        ; Is this account funded? If not, let's replace it with the default
        ; address probabilistically; no sense in pulling money out of thin air.
        from  (if (and (< (rand) 1.0)
                       (not (get (:funded? gen) from)))
                1
                from)
        ; How many actions should we generate?
        n     (inc (rand-int (:max-txn-size gen)))
        ; Construct ops
        ops (->> (range n)
                 (mapv (fn [_]
                         {:type   :transfer
                          :from   from
                          :to     (gen-rand-key gen)
                          :amount (if (u/default-account-id? from)
                                    ; If this is the first write, give them a
                                    ; bunch to play with; otherwise almost
                                    ; every transfer will fail.
                                    (-> 100 rand-int inc (* u/fee 10))

                                    ; For transfers between normal accounts,
                                    ; pick 1-100x fee
                                    (-> 100 rand-int inc (* u/fee)))
                          :rri    @(:token-rri gen)})))
        ; What accounts are we touching?
        tos   (set (map :to ops))
        ; Don't bother with default accounts; they're excluded from write
        ; counting
        accts (->> (conj tos from)
                   (remove u/default-account-id?))
        ; Record those as being written
        gen' (reduce gen-record-write! gen accts)
        ; And bump the txn id
        gen' (update gen' :next-txn-id inc)]

    [{:id   (:next-txn-id gen)
      :from from
      :ops  ops} gen']))

; This stores the state we need to select keys, and generates all three types
; of operations: transactions, balance reads, and txn-log reads.
(defrecord Generator
  [key-count
   key-dist
   key-dist-base
   max-writes-per-key
   max-txn-size
   accounts     ; An atom to an accounts structure
   token-rri    ; A promise of an RRI for the token we'll transfer
   key-pool     ; A vector of active keys; always of size key-count
   write-counts ; A map of keys to the number of times they've been written.
   funded?      ; A map of keys to whether we think they currently contain XRD.
   next-key     ; What's the next key we'll allocate?
   next-txn-id  ; What's our next transaction ID?
   ]
  gen/Generator
  (update [this test context event]
    (let [{:keys [type f value]} event]
      ; For transactions...
      (case f
        ; When we see a txn go through...
        :txn
        (case (:type event)
          ; Record receiving accounts as being funded
          :ok (let [funded?' (reduce (fn [funded? {:keys [to]}]
                                       (assoc funded? to true))
                                     funded?
                                     (:ops value))]
                (assoc this :funded? funded?'))

          ; When a transaction fails, decrement its write count; we can give it
          ; another shot.
          :fail (let [wc' (->> (:ops value)
                               (map :to)
                               (cons (:from value))
                               set
                               (reduce (fn [wc k]
                                         (if (contains? wc k)
                                           (update wc k dec)
                                           wc))
                                       write-counts))]
                  (assoc this :write-counts wc'))

          this)

        ; Not a txn
        this)))

  (op [this test context]
    ; Generate a generic invocation
    (let [op (gen/fill-in-op {} context)]
      (if (= :pending op)
        ; Every process is busy right now
        [:pending this]

        ; Right, what thread is this?
        (let [t (->> op :process (gen/process->thread context))
              ; How far into the concurrency of the test is that?
              zone (/ t (count (:workers context)))
              ; Pick a f based on the zone: first third do txns.
              f (if (< zone 1/3)
                  :txn
                  (rand-nth [:txn-log :balance]))
              op (assoc op :f f)]
          (case f
            :txn (let [[transfer gen'] (gen-transfer! this)]
                   [(assoc op :value transfer)
                    gen'])

            ; For transaction logs and balances, we either select a key from the
            ; pool, or our default account 1.
            :txn-log [(assoc op :value {:account (gen-rand-read-key this)})
                      this]

            :balance [(assoc op :value {:account (gen-rand-read-key this)})
                      this]))))))

(defn generator!
  "Constructs a Generator out of an options map. Options are:

    :accounts             An atom to an accounts structure

    :key-dist             Controls probability distribution for keys being
                          selected for a given operation. Choosing :uniform
                          means every key has an equal probability of appearing.
                          :exponential means that key i in the current key pool
                          is k^i times more likely than the first key to be
                          chosen. Defaults to :exponential.

    :key-dist-base        The base for an exponential distribution. Defaults
                          to 2, so the first key is twice as likely as the
                          second, which is twice as likely as the third, etc.

    :key-count            Number of distinct keys at any point. Defaults to
                          10 for exponential, 3 for uniform.

    :max-writes-per-key   Maximum number of operations per key. Defaults to 32.

  The selection of account IDs is a little tricky.

  We want some accounts to be frequently accessed in order to create contention
  and find race conditions. We also want some accounts to be infrequently
  accessed to expose behaviors over longer time horizons without growing to
  enormous size. This implies we should choose some sort of biased
  distribution: we use an exponential distribution.

  Some accounts (1-5) start with a good chunk of XRD; the others have none at
  all initially. This suggests that we need to involve XRD-bearing accounts
  throughout the lifespan of the test; otherwise we'll spread a fixed pool of
  XRD over a larger and larger group of accounts and hit more and more
  insufficient-balance errors. We want *some* insufficient balances (since this
  is an important invariant to test!) but not so many that transfers never
  happen.

  Moreover, fees continually drain money out of the system, which implies we
  should keep involving the default accounts in transfers throughout the
  lifespan of the test.

  We *also* want to limit the number of transfers per account, so that
  per-account histories are easier to read and don't take too long to query.
  That implies we need a constantly-rotating pool of keys, from which we take
  an exponential distribution:

  █
  █     [we gradually rotate higher keys]
  █
  █     █▅▂▂▁█▅█▅▂█▅▂▂▁
  12345 6789...

  But this doesn't help us bound histories: default accounts will accrue huge
  numbers of transactions over the course of the history. So instead, we treat
  these accounts specially: when we *would* have transferred money from a fresh
  account, we emit a special transaction which fills up that account with funds
  from a default account. From that point on, we can derive our account IDs
  from an exponentially-distributed rotating pool of non-default accounts.

  As a side-effect, adds initial accounts to the accounts atom."
  [opts]
  (let [key-dist  (:key-dist opts :exponential)
        key-count (:key-count opts (case key-dist
                                     :exponential 10
                                     :uniform     3))
        key-pool (->> (iterate inc 1)
                      (remove u/default-account-id?)
                      (take key-count)
                      vec)]
    ; Record initial keys as accounts
    (doseq [k key-pool]
      (swap! (:accounts opts) conj-small-account k))
    ; And build generator
    (map->Generator
      {:accounts           (:accounts opts)
       :token-rri          (:token-rri opts)
       :key-dist           key-dist
       :key-dist-base      (:key-dist-base opts 2)
       :key-count          key-count
       :max-writes-per-key (:max-writes-per-key opts 32)
       :max-txn-size       (:max-txn-size opts 4)
       :key-pool           key-pool
       :write-counts       {}
       :funded?            {}
       :next-key           (inc (peek key-pool))
       :next-txn-id        0})))

(defn workload
  "Constructs a package of a client and generator."
  [opts]
  (let [accounts  (atom (initial-accounts))
        token-rri (promise)]
    {:client          (client accounts token-rri)
     :checker         (rchecker/checker)
     :generator       (generator! (assoc opts
                                         :accounts accounts
                                         :token-rri token-rri))
     :final-generator (gen/each-thread
                        (delay
                          (->> @accounts
                               :accounts
                               (map :id)
                               (map (fn [acct]
                                      {:f :txn-log, :value {:account acct}})))))}))
